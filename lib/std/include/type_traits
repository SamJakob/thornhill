#pragma once

namespace std {

    template<typename _Tp>
    class reference_wrapper;

    // integral_constant
    template<typename _Tp, _Tp __v>
    struct integral_constant {
        static constexpr _Tp                    value = __v;
        typedef _Tp                             value_type;
        typedef integral_constant<_Tp, __v>     type;
        constexpr operator value_type() const noexcept { return value; }

        // integral_constant_callable
#define __cpp_lib_integral_constant_callable 201304L
        constexpr value_type operator()() const noexcept { return value; }
    };

    // bool_constant
#define __cpp_lib_bool_constant 201505L
    template<bool __v>
    using bool_constant = integral_constant<bool, __v>;

    // true_type: compile-time boolean with true value.
    using true_type = integral_constant<bool, true>;

    // false_type: compile-time boolean with false value.
    using false_type = integral_constant<bool, false>;

    // is_const
    template<typename>
    struct is_const : public false_type {};

    template<typename _Tp>
    struct is_const<_Tp const> : public true_type {};

    // is_volatile
    template<typename>
    struct is_volatile : public false_type {};

    template<typename _Tp>
    struct is_volatile<_Tp volatile> : public true_type {};

    // is_enum
    template<typename _Tp>
    struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {};

    // is_union
    template<typename _Tp>
    struct is_union : public integral_constant<bool, __is_union(_Tp)> {};

    // is_class
    template<typename _Tp>
    struct is_class : public integral_constant<bool, __is_class(_Tp)> {};

    // is_function
    template<typename _Tp>
        struct is_function : public bool_constant<!is_const<const _Tp>::value> {};

    template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl {
        using type = __underlying_type(_Tp);
    };

    template<typename _Tp>
    struct __underlying_type_impl<_Tp, false> {};

    // The underlying type, of an enum.
    template<typename _Tp>
    struct underlying_type : public __underlying_type_impl<_Tp> {};

    // enable_if: define a member typedef `type` only if a boolean constant is true.
    template<bool, typename _Tp = void>
    struct enable_if {};

    // enable_if(true): partial specialization for true.
    template<typename _Tp>
    struct enable_if<true, _Tp> { typedef _Tp type; };

    // __enable_if_t (std::enable_if_t for C++ 11)
    template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

    template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;

}
